{{- include "manticore.validateTables" . -}}
# =============================================================================
# Manticore Search Configuration
# =============================================================================
# Base searchd config (startup script generates runtime config with IP-bound listeners)
kind: secret
name: {{ include "manticore.secretConfigName" . }}
description: Manticore searchd base configuration
tags: {{- include "manticore.tags" . | nindent 4 }}
type: opaque
data:
  encoding: plain
  payload: |-
    searchd {
        listen = 9306:mysql
        listen = 9308:http
        listen = 9312
        data_dir = /var/lib/manticore
        binlog_path = /var/lib/manticore/binlog
        log = /dev/stdout
        query_log = /dev/stdout
        pid_file = /var/run/searchd.pid
        seamless_rotate = 1
        preopen_tables = 1
    }
---
# =============================================================================
# Schema Registry
# =============================================================================
# Table schemas for agent (creates RT delta tables, parses CSV, builds distributed tables)
kind: secret
name: {{ include "manticore.secretSchemaConfigName" . }}
description: Schema registry for multi-table configuration
tags: {{- include "manticore.tags" . | nindent 4 }}
type: opaque
data:
  encoding: plain
  payload: |-
    # Schema Registry (YAML format, read by agent)
    # See README.md for column types and configuration options
    {{- range .Values.tables }}

    {{ .name }}:
      config:
        {{- .config | toYaml | nindent 8 }}
      schema:
        columns:
          {{- range .schema.columns }}
          - name: {{ .name }}
            type: {{ .type }}
          {{- end }}
    {{- end }}
---
# =============================================================================
# Manticore Startup Script
# =============================================================================
# Generates runtime config, starts searchd, handles graceful shutdown
# Cluster init (bootstrap/join) handled by agent via orchestrator API
kind: secret
name: {{ include "manticore.secretStartupName" . }}
description: Manticore searchd startup and shutdown handler
tags: {{- include "manticore.tags" . | nindent 4 }}
type: opaque
data:
  encoding: plain
  payload: |-
    #!/usr/bin/env bash
    set -euo pipefail

    # =============================================================================
    # CONFIGURATION
    # =============================================================================

    CLUSTER_NAME="{{ .Values.manticore.clusterName }}"
    MYSQL_PORT=9306
    HTTP_PORT=9308
    REPL_PORT=9312
    WORKLOAD_NAME="$(echo "${HOSTNAME}" | sed 's/-[0-9]*$//')"
    REPLICA_INDEX="$(echo "${HOSTNAME}" | awk -F'-' '{print $NF}')"
    LOCATION=$(basename "${CPLN_LOCATION}")
    # Internal DNS format: {workloadName}-{replicaIndex}.{workloadName}
    NODE0_FQDN="${WORKLOAD_NAME}-0.${WORKLOAD_NAME}"
    NODE0_ADDR="${NODE0_FQDN}:${REPL_PORT}"

    echo "============================================"
    echo "Manticore Startup"
    echo "============================================"
    echo "Hostname:       ${HOSTNAME}"
    echo "Replica Index:  ${REPLICA_INDEX}"
    echo "Cluster:        ${CLUSTER_NAME}"
    echo "Node 0 FQDN:    ${NODE0_FQDN}"
    echo "============================================"
    echo ""

    # Create required directories
    echo "Creating directories..."
    mkdir -p /var/lib/manticore/binlog
    mkdir -p /var/lib/manticore/data
    echo "Directories created."

    RUNTIME_CONFIG="/var/lib/manticore/manticore-runtime.conf"

    # =============================================================================
    # HELPER FUNCTIONS
    # =============================================================================

    mysql_exec() {
      local host="${1:-127.0.0.1}"
      shift || true
      mysql --protocol=tcp -h "${host}" -P "${MYSQL_PORT}" -N -B "$@"
    }

    wait_for_manticore() {
      echo "Waiting for Manticore MySQL port ${MYSQL_PORT}..."
      for i in $(seq 1 60); do
        if mysql --protocol=tcp -h 127.0.0.1 -P "${MYSQL_PORT}" -e "SELECT 1" >/dev/null 2>&1; then
          echo "Manticore is ready."
          return 0
        fi
        echo "  [$i/60] not ready yet..."
        sleep 1
      done
      echo "ERROR: Manticore did not become ready on ${MYSQL_PORT}"
      return 1
    }

    # =============================================================================
    # GRACEFUL SHUTDOWN HANDLER
    # =============================================================================

    shutdown() {
      echo ""
      echo "============================================"
      echo "SIGTERM received: graceful shutdown"
      echo "============================================"

      echo "Stopping searchd gracefully..."
      if searchd --stopwait --config "${RUNTIME_CONFIG}"; then
        echo "searchd stopped gracefully"
      else
        echo "searchd --stopwait failed, falling back to kill"
        if [[ -n "${SEARCHD_PID:-}" ]] && kill -0 "$SEARCHD_PID" >/dev/null 2>&1; then
          kill "$SEARCHD_PID" || true
          for _ in $(seq 1 30); do
            kill -0 "$SEARCHD_PID" >/dev/null 2>&1 || break
            sleep 1
          done
        fi
      fi

      # Keep manticore.json on all replicas so they remember cluster state and
      # table associations. This allows IST (incremental sync) instead of full SST
      # when rejoining, and ensures local tables are recognized as cluster tables.
      if [[ "${REPLICA_INDEX}" != "0" ]]; then
        echo "Requesting cluster node refresh on replica-0..."
        mysql_exec "${NODE0_FQDN}" -e "ALTER CLUSTER ${CLUSTER_NAME} UPDATE nodes" || true
      fi

      echo "Shutdown sequence complete."
      echo "============================================"
    }

    trap shutdown TERM INT

    # =============================================================================
    # START MANTICORE
    # =============================================================================

    echo ""
    echo "============================================"
    echo "Preparing searchd configuration..."
    echo "============================================"

    # Get the pod's IP address and FQDN for replication binding
    MY_IP=$(hostname -i | awk '{print $1}')
    MY_FQDN="${WORKLOAD_NAME}-${REPLICA_INDEX}.${WORKLOAD_NAME}"
    echo "Pod IP address: ${MY_IP}"
    echo "Pod FQDN: ${MY_FQDN}"

    # Create runtime config with dynamic replication listener
    echo "Generating runtime config: ${RUNTIME_CONFIG}"

    echo "searchd {"                              > "${RUNTIME_CONFIG}"
    echo "    listen = 127.0.0.1:9306:mysql"     >> "${RUNTIME_CONFIG}"
    echo "    listen = ${MY_IP}:9306:mysql"      >> "${RUNTIME_CONFIG}"
    echo "    listen = 127.0.0.1:9308:http"      >> "${RUNTIME_CONFIG}"
    echo "    listen = ${MY_IP}:9308:http"       >> "${RUNTIME_CONFIG}"
    echo "    listen = 127.0.0.1:9312"           >> "${RUNTIME_CONFIG}"
    echo "    listen = ${MY_IP}:9312"            >> "${RUNTIME_CONFIG}"
    echo "    listen = ${MY_IP}:9313-9320:replication" >> "${RUNTIME_CONFIG}"
    echo "    node_address = ${MY_FQDN}"         >> "${RUNTIME_CONFIG}"
    echo "    data_dir = /var/lib/manticore"     >> "${RUNTIME_CONFIG}"
    echo "    binlog_path = /var/lib/manticore/binlog" >> "${RUNTIME_CONFIG}"
    echo "    log = /dev/stdout"                 >> "${RUNTIME_CONFIG}"
    echo "    query_log = /dev/stdout"           >> "${RUNTIME_CONFIG}"
    echo "    pid_file = /var/run/searchd.pid"   >> "${RUNTIME_CONFIG}"
    echo "    seamless_rotate = 1"               >> "${RUNTIME_CONFIG}"
    echo "    preopen_tables = 1"                >> "${RUNTIME_CONFIG}"
    echo "    server_id = ${REPLICA_INDEX}"      >> "${RUNTIME_CONFIG}"
    echo "}"                                     >> "${RUNTIME_CONFIG}"

    echo "Runtime config generated:"
    cat "${RUNTIME_CONFIG}"
    echo ""

    echo "============================================"
    echo "Starting searchd..."
    echo "============================================"

    echo ""
    echo "Launching searchd in background..."
    searchd --config "${RUNTIME_CONFIG}" --nodetach 2>&1 &
    SEARCHD_PID="$!"
    echo "searchd launched with PID: ${SEARCHD_PID}"

    sleep 2

    if ! kill -0 "${SEARCHD_PID}" 2>/dev/null; then
      echo "ERROR: searchd exited immediately! Check config."
      exit 1
    fi

    echo "searchd is running. Waiting for MySQL port..."
    wait_for_manticore

    # =============================================================================
    # CLUSTER STATUS CHECK (cluster setup is handled by orchestrator init)
    # =============================================================================

    echo ""
    echo "============================================"
    echo "Cluster Status"
    echo "============================================"

    # Check if already part of a cluster (from preserved state in manticore.json)
    # Wait a few seconds for cluster module to load state
    sleep 3
    CLUSTER_STATUS=$(mysql_exec 127.0.0.1 -e "SHOW STATUS LIKE 'cluster_${CLUSTER_NAME}_status'" 2>/dev/null || echo "")

    if echo "${CLUSTER_STATUS}" | grep -qE "(primary|synced)"; then
      echo "Already part of cluster ${CLUSTER_NAME}."
    else
      echo "Not part of any cluster. Run orchestrator init to bootstrap/join cluster."
    fi

    # =============================================================================
    # KEEP CONTAINER ALIVE
    # =============================================================================

    echo ""
    echo "============================================"
    echo "Startup complete"
    echo "============================================"
    echo "searchd PID: ${SEARCHD_PID}"
    echo "============================================"
    echo ""
    echo "Import operations are handled by the agent sidecar."
    echo "Use the orchestrator workload for coordinated imports."
    echo ""

    wait "${SEARCHD_PID}"
---
# =============================================================================
# Agent Authentication Token
# =============================================================================
# Bearer token for orchestrator/agent/UI communication
# Generate with: openssl rand -base64 32
kind: secret
name: {{ include "manticore.secretAgentTokenName" . }}
description: Bearer token for orchestrator-agent authentication
tags: {{- include "manticore.tags" . | nindent 4 }}
type: opaque
data:
  encoding: plain
  payload: {{ required "agent.token is required" .Values.orchestrator.agent.token }}

# =============================================================================
# K6 Load Test Script
# =============================================================================
{{- if .Values.loadTest.enabled }}
---
# Generated k6 script from loadTest.* values
kind: secret
name: {{ include "manticore.secretK6ScriptName" . }}
description: K6 load test script for Manticore search
tags: {{- include "manticore.tags" . | nindent 4 }}
type: opaque
data:
  encoding: plain
  payload: |-
    import http from 'k6/http';
    import { check } from 'k6';
    import { Rate } from 'k6/metrics';

    const errorRate = new Rate('errors');

    export const options = {
      vus: {{ .Values.loadTest.vus }},
      duration: '{{ .Values.loadTest.duration }}',
      thresholds: {
        'http_req_duration': ['p(95)<{{ .Values.loadTest.thresholds.p95ResponseTime }}'],
        'http_req_failed': ['rate<{{ .Values.loadTest.thresholds.errorRate }}'],
      },
    };

    const BASE_URL = 'http://{{ include "manticore.name" . }}.{{ .Values.global.cpln.gvc }}.cpln.local:{{ .Values.loadTest.target.port }}';

    const QUERY = JSON.stringify({{ .Values.loadTest.query | toJson }});

    export default function () {
      const res = http.post(`${BASE_URL}/{{ .Values.loadTest.target.endpoint }}`, QUERY, {
        headers: { 'Content-Type': 'application/json' },
      });

      const success = check(res, {
        'status is 200': (r) => r.status === 200,
      });

      errorRate.add(!success);
    }
{{- end }}
